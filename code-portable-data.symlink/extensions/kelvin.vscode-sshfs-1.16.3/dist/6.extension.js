exports.ids=[6],exports.modules={61:function(e,t,o){"use strict";o.r(t),o.d(t,"calculateActualConfig",function(){return f}),o.d(t,"createSocket",function(){return w}),o.d(t,"createSSH",function(){return y}),o.d(t,"getSFTP",function(){return g});var n=o(5),r=o(10),s=o(36),i=o(24),a=o(0),u=o(2),p=o(1),c=o(3),d=function(e,t,o,n){return new(o||(o=Promise))(function(r,s){function i(e){try{u(n.next(e))}catch(e){s(e)}}function a(e){try{u(n.throw(e))}catch(e){s(e)}}function u(e){e.done?r(e.value):new o(function(t){t(e.value)}).then(i,a)}u((n=n.apply(e,t||[])).next())})};const m=o(32),h={tryKeyboard:!0,keepaliveInterval:3e4};function l(e){return"string"!=typeof e?e:e.replace(/\$\w+/g,e=>process.env[e.substr(1)]||"")}function f(e){return d(this,void 0,void 0,function*(){if("_calculated"in e)return e;(e=Object.assign({},e))._calculated=!0,e.username=l(e.username),e.host=l(e.host);const t=l((e.port||"")+"");if(t&&(e.port=Number(t)),e.agent=l(e.agent),e.privateKeyPath=l(e.privateKeyPath),p.d(`[${e.name}] Calculating actual config`),e.putty){"win32"!==process.platform&&p.e(`[${e.name}] \tConfigurating uses putty, but platform is ${process.platform}`);let t=!0;if(!0===e.putty){if(!e.host)throw new Error("'putty' was true but 'host' is empty/missing");e.putty=e.host,t=!1}else e.putty=l(e.putty);const n=yield(yield o.e(5).then(o.bind(null,50))).getSession(e.putty,e.host,e.username,t);if(!n)throw new Error("Couldn't find the requested PuTTY session");if("ssh"!==n.protocol)throw new Error("The requested PuTTY session isn't a SSH session");if(e.username=e.username||n.username,!e.username&&n.hostname&&n.hostname.indexOf("@")>=1&&(e.username=n.hostname.substr(0,n.hostname.indexOf("@"))),e.host=e.host||n.hostname,e.port=n.portnumber||e.port,e.agent=e.agent||(n.tryagent?"pageant":void 0),n.usernamefromenvironment&&(e.username=process.env.USERNAME||process.env.USER,!e.username))throw new Error("Trying to use the system username, but process.env.USERNAME or process.env.USER is missing");switch(e.privateKeyPath=e.privateKeyPath||!e.agent&&n.publickeyfile||void 0,n.proxymethod){case 0:break;case 1:case 2:case 3:if(!n.proxyhost)throw new Error("Proxymethod is SOCKS 4/5 or HTTP but 'proxyhost' is missing");e.proxy={host:n.proxyhost,port:n.proxyport,type:1===n.proxymethod?"socks4":2===n.proxymethod?"socks5":"http"};break;default:throw new Error("The requested PuTTY session uses an unsupported proxy method")}p.b(`[${e.name}] \tReading PuTTY configuration lead to the following configuration:\n${JSON.stringify(e,null,4)}`)}if(e.privateKeyPath)try{const t=yield Object(c.b)(t=>Object(n.readFile)(e.privateKeyPath,t));e.privateKey=t,p.b(`[${e.name}] \tRead private key from ${e.privateKeyPath}`)}catch(t){throw new Error(`Error while reading the keyfile at:\n${e.privateKeyPath}`)}if(e.username&&!0!==e.username||(e.username=yield a.window.showInputBox({ignoreFocusOut:!0,placeHolder:"Username",prompt:`Username for ${e.name}`})),!0===e.password&&(e.password=yield a.window.showInputBox({password:!0,ignoreFocusOut:!0,placeHolder:"Password",prompt:`Password for ${e.username}@${e.name}`})),e.password&&(e.agent=void 0),!0===e.passphrase)if(e.privateKey)e.passphrase=yield a.window.showInputBox({password:!0,ignoreFocusOut:!0,placeHolder:"Passphrase",prompt:`Passphrase for provided export/private key for ${e.username}@${e.name}`});else{yield a.window.showWarningMessage(`The field 'passphrase' was set to true, but no key was provided for ${e.username}@${e.name}`,"Ignore")}else!1===e.passphrase&&delete e.passphrase;return p.b(`[${e.name}] \tFinal configuration:\n${JSON.stringify(p.a(e),null,4)}`),e})}function w(e){return d(this,void 0,void 0,function*(){if(!(e=yield f(e)))return null;if(p.d(`[${e.name}] Creating socket`),e.hop){p.b(`\tHopping through ${e.hop}`);const t=Object(u.d)().find(t=>t.name===e.hop);if(!t)throw new Error(`A SSH FS configuration with the name '${e.hop}' doesn't exist`);const o=yield y(t);return o?new Promise((t,n)=>{o.forwardOut("localhost",0,e.host,e.port||22,(r,s)=>{if(r)return p.b(`\tError connecting to hop ${e.hop} for ${e.name}: ${r}`),r.message=`Couldn't connect through the hop:\n${r.message}`,n(r);s.once("close",()=>o.destroy()),t(s)})}):(p.b(`[${e.name}] \tFailed in connecting to hop ${e.hop}`),null)}switch(e.proxy&&e.proxy.type){case null:case void 0:break;case"socks4":case"socks5":return yield(yield Promise.all([o.e(0),o.e(1)]).then(o.bind(null,33))).socks(e);case"http":return yield(yield Promise.all([o.e(0),o.e(1)]).then(o.bind(null,33))).http(e);default:throw new Error("Unknown proxy method")}return new Promise((t,o)=>{p.b(`[${e.name}] Connecting to ${e.host}:${e.port||22}`);const n=new r.Socket;n.connect(e.port||22,e.host,()=>t(n)),n.once("error",o)})})}function y(e,t){return d(this,void 0,void 0,function*(){return(e=yield f(e))&&(t=t||(yield w(e)))?new Promise((o,n)=>{const r=new s.Client;r.once("ready",()=>o(r)),r.once("timeout",()=>n(new Error(`Socket timed out while connecting SSH FS '${e.name}'`))),r.on("keyboard-interactive",(t,o,n,r,s)=>{p.b(`[${e.name}] Received keyboard-interactive request with prompts "${JSON.stringify(r)}"`),Promise.all(r.map(e=>a.window.showInputBox({password:!0,ignoreFocusOut:!0,prompt:e.prompt.replace(/:\s*$/,"")}))).then(s)}),r.on("error",t=>{t.description&&(t.message=`${t.description}\n${t.message}`),p.c(`[${e.name}] ${t.message||t}`),n(t)});try{p.d(`[${e.name}] Creating SSH session over the opened socket`),r.connect(Object.assign(e,{sock:t},h))}catch(e){n(e)}}):null})}function g(e,t){return d(this,void 0,void 0,function*(){if(!(t=yield f(t)))throw new Error("Couldn't calculate the config");if(t.sftpSudo&&!t.sftpCommand&&(p.e(`[${t.name}] sftpSudo is set without sftpCommand. Assuming /usr/lib/openssh/sftp-server`),t.sftpCommand="/usr/lib/openssh/sftp-server"),!t.sftpCommand)return p.d(`[${t.name}] Creating SFTP session using standard sftp subsystem`),Object(c.b)(t=>e.sftp(t));let o=t.sftpCommand;p.d(`[${t.name}] Creating SFTP session using specified command: ${o}`);const n=yield Object(c.b)(t=>e.shell(!1,t));if(o.match(/^sudo/)){const e=o.match(/\-u\s+(\S+)/)||o.match(/\-\-user=(\S+)/);t.sftpSudo=!e||e[1],t.sftpCommand=o=function(e){let t=e=e.replace(/^sudo\s+/,"");for(;e=t.trim(),(t=e.replace(/^\-\-\s+/,""))===e&&((t=e.replace(/^\-[AbEeKklnPSsVv]/,""))!==e||(t=e.replace(/^\-[CHhprtUu]\s+\S+/,""))!==e||(t=e.replace(/^\-\-(close\-from|group|host|role|type|other\-user|user)=\S+/,""))!==e););return e}(o),p.e(`[${t.name}] Reformed sftpCommand due to sudo to: ${o}`)}t.sftpSudo&&(yield function(e,t,o=!0){return p.b(`[${t.name}] Turning shell into a sudo shell for ${"string"==typeof o?`'${o}'`:"default sudo user"}`),new Promise((n,r)=>{function s(e){if("SUDO OK"===(e=e.toString()).trim())return u(),n();p.b(`[${t.name}] Unexpected STDOUT: ${e}`)}function i(o){return d(this,void 0,void 0,function*(){if((o=o.toString()).match(/^\[sudo\]/)){const n="string"==typeof t.password?t.password:yield a.window.showInputBox({password:!0,ignoreFocusOut:!0,placeHolder:"Password",prompt:o.substr(7)});return n?e.write(`${n}\n`):(u(),r(new Error("No password given")))}return u(),r(new Error(`Sudo error: ${o}`))})}function u(){e.stdout.removeListener("data",s),e.stderr.removeListener("data",i)}e.stdout.on("data",s),e.stderr.on("data",i);const c="string"==typeof o?`-u ${o} `:"";e.write(`sudo -S ${c}bash -c "echo SUDO OK; cat | bash"\n`)})}(n,t,t.sftpSudo)),n.write("echo SFTP READY\n"),yield new Promise((e,t)=>{const o=t=>{"SFTP READY"===t.toString().trim()&&(n.stdout.removeListener("data",o),e())};n.stdout.on("data",o),n.on("close",t)});const r=new i.SFTPStream({debug:t.debug});n.pipe(r).pipe(n);const s=new m(r);return yield Object(c.b)(e=>n.write(`${o}\n`,e)),s})}}};
//# sourceMappingURL=6.extension.js.map